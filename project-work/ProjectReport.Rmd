---
title: "Final Project - Linear Regression Curves"
author: "Priyesh Kannan & Michael Sean Sinykin"
date: "Tuesday, June 2, 2015"
output: pdf_document
---


# Description


Our project focused upon the tradability of signals generated by linear regression curves (LRC) and there less-sensitive counterparts, the simple moving averages (SMA).  To construct a linear regression curve, we choose a period over which to regress, for example n=20.  Starting from the beginning of our time series (t=0), we take the first n observations, construct a linear regression line through the data, and define our linear regression curve (LRC) at n=20 as the value of our linear regression line at n=20.  We then construct a similar linear regression line starting from t=1 to arrive at the value of our LRC at n=21.  Iterating through our time series, we build up our LRC in this way.  For more information, see http://gekkoquant.com/2013/09/29/high-probability-credit-spreads-using-linear-regression-curves/.

In constructing the LRC, we compared it to the SMA of the same period, and noticed that the LRC was more responsive to the actual price movement than the SMA.  Similar to the above-referenced Gekko Trading post, we decided to exploit this sensitivity by creating a LRC-SMA crossover system, optimizing LRC vs SMA.   

```{r,init.for.curve,echo=FALSE,results='hide',message=FALSE}
library(quantmod)
symbol<-'SPY'
options("getSymbols.warning4.0"=FALSE)
startDate <- '2005-01-30'
endDate<- '2014-06-30'
getSymbols(Symbols = symbol,index.class  = 'POSIXct',
           from =startDate,to = endDate,adjust=FALSE)

for(asset in symbol){
    assign(x=asset,value= adjustOHLC(get(asset),use.Adjusted = TRUE))
}

LRC <- function(x,n){
    regression <- function(dataBlock){
        fit <-lm(dataBlock~seq(1,length(dataBlock),1))
        return(last(fit$fitted.values))
    }
    result<-rollapply(x,width=n,regression,align="right",by.column=FALSE)
    return(result)
}

myTheme<-chart_theme()
myTheme$col$up.col<-'lightgreen'
myTheme$col$dn.col<-'pink'
data<- LRC(Cl(get(symbol)),20)
```


```{r,LRCSMA20curves,echo=FALSE,fig.width=7,fig.height=5,fig.keep="last",warning=FALSE}
chart_Series(x = get(symbol),subset="2014::", symbol = symbol,name = symbol,theme=myTheme)
add_SMA(n=20,col ="blue",lwd=2,on = 1)
add_TA(x =data,name="LRC",col ="red",lwd=2,on = 1)
legend(2,193,legend=c("LRC","SMA"),lwd=c(2,2),col=c("red","blue"),bty="n")
```


For our instrument, we chose SPY, daily data from 01/30/1999 to 06/30/2014. For our training period, we chose 4 years for training and 1 year for testing, conducting WFA through the time series.  



## Defining Our Trade Rules

We  kept our system simple, in order to retain system robustness (generating statistically significant numbers of trades during back tests) and to help avoid curve-fitting traps.  Our original plan was to test as a long only as well as long-short system, but found out rather quickly that sequential processing for parameter optimization on our Windows systems can be prohibitively time-consuming, so we settled for a long-only crossover system.  Because we found the LRC to be more sensitive to changes in underlying price trends, we set our bullish entries (buy long) to be triggered when the LRC broke above the SMA.  Conversely, our sell signal was triggered when the LRC broke down below our SMA.  

We also set up stop losses and trailing stops, in addition to profit-taking sells.  Optimizing where to take profits was an interesting exercise, as will be reported below, as the robustness was suspect in all but a narrow range.  Again, with more time, we would have liked to do further analysis to determine whether taking profits ends up being a net-positive to the system.  





## Designing and Formatting


We begin with a bit of initialization and historic data-fetching:

```{r,initialize.download,echo=TRUE,results='hide',message=FALSE}
rm(list=ls())

library(FinancialInstrument)
library(TTR)
library(blotter)
library(quantstrat)
library(lattice)

.blotter <- new.env()
.strategy <- new.env()
Sys.setenv(TZ="UTC")
STRATEGY<-'LRC'
PORTOLIO.NAME<-'PORTFOLIO.LRC.STOP'
ACCOUNT.NAME<-'AC.LRC.STOP'

try(rm.strat(PORTOLIO.NAME))

symbol<-c('SPY')
currency("USD")
stock(primary_id = symbol,currency = "USD",multiplier = 1)
Sys.setenv(TZ="UTC")

initDate <- '2004-12-31'
startDate <- '2005-01-30'
endDate<- '2014-06-30'

initEq <- 1e6

options("getSymbols.warning4.0"=FALSE)
getSymbols(Symbols = symbol,index.class  = 'POSIXct',
           from =startDate,to = endDate,adjust=TRUE)
```


Next we set up functions to construct our LRC and calculate and account for transaction costs and slippage, in addition to Portfolio, Accounts, and Orders initialization.  For transactions costs, we referred to http://www.rinfinance.com/agenda/2013/workshop/Humme+Peterson.pdf, particularly with respect to the fact that transaction costs are borne at exit (if bought long).  For our long-only strategy, the takeaway is that our estimate of transaction fees is for a round-trip trade (both the buy to open the position and the sell to close it out).


```{r,functions,echo=TRUE,results='hide',message=FALSE}
#------------------------------------------------------------------------------------------------
# LRC
#------------------------------------------------------------------------------------------------
LRC <- function(x,n){
  
  regression <- function(dataBlock){
    fit <-lm(dataBlock~seq(1,length(dataBlock),1))
    return(last(fit$fitted.values))
  }
  return (rollapply(x,width=n,regression,align="right",by.column=FALSE))
}
#------------------------------------------------------------------------------------------------
# Fees Function
#------------------------------------------------------------------------------------------------

evalTxnFees<-function(TxnQty, TxnPrice, Symbol,brokerage=0.005,impactCost=0.05)
{
  txnCost<- abs(round(brokerage*(TxnPrice+impactCost)*TxnQty,2))*-1
  return(txnCost)
}
#------------------------------------------------------------------------------------------------
#  Initialization
#------------------------------------------------------------------------------------------------

initPortf(name = PORTOLIO.NAME,symbols = symbol,initDate=initDate)
initAcct(name = ACCOUNT.NAME,portfolios = PORTOLIO.NAME,initDate=initDate,initEq=initEq)
initOrders(portfolio = PORTOLIO.NAME,initDate=initDate)
```


Next, taking our trading rules as discussed above, we add our indicators (LRC and SMA, in this case optimized to LRC=20, SMA=30), our signals (LRC crossing above or below SMA), our rules (buy long when LRC crosses above SMA, sell position when LRC crosses below SMA), as well as our stop loss rule, trailing stop rule, and profit taking rule.


```{r,strategy,echo=TRUE,results='hide',message=FALSE}
strategy(STRATEGY,store=TRUE)

add.indicator(strategy = STRATEGY,name='LRC',
              arguments=list(x=quote(Cl(mktdata)),n=20),
              label='LRC')

add.indicator(strategy = STRATEGY,name='SMA',
              arguments=list(x=quote(Cl(mktdata)),n=30),
              label='SMA')



LONG.ENTRY.SIGNAL<-"LRC_GT_SMA_SIG"
LONG.EXIT.SIGNAL<-"LRC_LT_SMA_SIG"
LONG.ENTRY.RULE<-'L_ENTRY_LRC_SMA_RULE'
LONG.EXIT.RULE<-'L_EXIT_LRC_SMA_RULE'
LONG.ORDERSET.NAME<-'LRCLONGSMA'

add.signal(strategy = STRATEGY,name="sigCrossover",
           arguments=list(columns=c('LRC','SMA'),
                          relationship="gt"),
           label=LONG.ENTRY.SIGNAL)

add.signal(strategy = STRATEGY,name="sigCrossover",
           arguments=list(columns=c('LRC','SMA'),
                          relationship="lt"),
           label=LONG.EXIT.SIGNAL)

add.rule(strategy = STRATEGY,name="ruleSignal",
         arguments=list(sigcol=LONG.ENTRY.SIGNAL,
                        sigval=TRUE,
                        orderqty=100,
                        ordertype="market",
                        TxnFees=0,
                        orderside="long",
                        orderset=LONG.ORDERSET.NAME),
         type="enter",
         label=LONG.ENTRY.RULE)

add.rule(strategy = STRATEGY,name="ruleSignal",
         arguments=list(sigcol=LONG.EXIT.SIGNAL,
                        sigval=TRUE,
                        orderqty='all',
                        ordertype="market",
                        TxnFees="evalTxnFees",
                        orderside="long",
                        orderset=LONG.ORDERSET.NAME),
         type="exit",
         label=LONG.EXIT.RULE)

#-------------------------------------------------------------------------------
# Stop Loss
#-----------------------------------------------------------------------------
stopLossPercent<-0.045
LONG.STOPLOSS.RULE<-"LE_LRCSMA_STOPLOSS_EXIT"

add.rule(strategy = STRATEGY,
         name="ruleSignal",
         arguments=list(sigcol=LONG.EXIT.SIGNAL,
                        replace=FALSE,
                        sigval=TRUE,
                        tmult=TRUE,
                        orderqty='all',
                        threshold=quote(stopLossPercent),
                        TxnFees="evalTxnFees",
                        ordertype="stoplimit",
                        orderside="long",
                        orderset=LONG.ORDERSET.NAME),
         type="chain",
         parent=LONG.ENTRY.RULE,
         label=LONG.STOPLOSS.RULE)

#-------------------------------------------------------------------------------
# trailing stop
#-----------------------------------------------------------------------------

trailingStopPercent<-0.07
LONG.TRAILINGSTOP.RULE<-"LE_LRCSMA_TRAILINGSTOP_EXIT"


add.rule(strategy = STRATEGY,name="ruleSignal",
         arguments=list(sigcol=LONG.EXIT.SIGNAL,
                        replace=FALSE,
                        sigval=TRUE,
                        orderqty='all',
                        TxnFees='evalTxnFees',
                        ordertype='stoptrailing',
                        tmult=TRUE,
                        threshold=quote(trailingStopPercent),
                        orderside='long',
                        orderset=LONG.ORDERSET.NAME),
         type="chain",parent=LONG.ENTRY.RULE,
         label=LONG.TRAILINGSTOP.RULE)

#-------------------------------------------------------------------------------
# Take Profit
#-----------------------------------------------------------------------------

takeProfit<-0.15
LONG.TAKEPROFIT.RULE<-"LE_LRCSMA_TAKEPROFIT_EXIT"

add.rule(strategy = STRATEGY,name="ruleSignal",
         arguments=list(sigcol=LONG.ENTRY.SIGNAL,
                        replace=FALSE,
                        sigval=TRUE,
                        orderqty='all',
                        TxnFees='evalTxnFees',
                        ordertype='limit',
                        tmult=TRUE,
                        threshold=quote(takeProfit),
                        orderside='long',
                        orderset=LONG.ORDERSET.NAME),
         type="chain",parent=LONG.ENTRY.RULE,
         label=LONG.TAKEPROFIT.RULE)
```


Next, we apply our strategy to our data and update our portfolio, account, and our ending equity position



```{r,applyStrategy,echo=TRUE,results='hide',message=FALSE}
#-----------------------------------------------------------------------------

applyStrategy(strategy =STRATEGY,portfolios = PORTOLIO.NAME,debug = TRUE)

#-------------------------------------------------------------------------------

getTxns(Portfolio = PORTOLIO.NAME,Symbol = symbol)

updatePortf(Portfolio = PORTOLIO.NAME)
updateAcct(name = ACCOUNT.NAME)
updateEndEq(Account = ACCOUNT.NAME)
```


Check data integrity
```{r,CBUfunc, echo=FALSE,message=FALSE,results='hide'}
checkBlotterUpdate <- function(port.st,account.st,verbose=TRUE)
{
  ok <- TRUE
  p <- getPortfolio(port.st)
  a <- getAccount(account.st)
  syms <- names(p$symbols)
  port.tot <- sum(sapply(syms,FUN = function(x) eval(parse(
    text=paste("sum(p$symbols",x,"posPL.USD$Net.Trading.PL)",sep="$")))))
  port.sum.tot <- sum(p$summary$Net.Trading.PL)
  if( !isTRUE(all.equal(port.tot,port.sum.tot)) ) {
    ok <- FALSE
    if( verbose )
      print("portfolio P&L doesn't match sum of symbols P&L")
  }
  initEq <- as.numeric(first(a$summary$End.Eq))
  endEq <- as.numeric(last(a$summary$End.Eq))
  if( !isTRUE(all.equal(port.tot,endEq-initEq)) ) {
    ok <- FALSE
    if( verbose )
      print("portfolio P&L doesn't match account P&L")
  }
  if( sum(duplicated(index(p$summary))) ) {
    ok <- FALSE
    if( verbose )
      print("duplicate timestamps in portfolio summary")
  }
  if( sum(duplicated(index(a$summary))) ) {
    ok <- FALSE
    if( verbose )
      print("duplicate timestamps in account summary")
  }
  return(ok)
}
```

```{r,data.int.check,echo=TRUE}
checkBlotterUpdate(PORTOLIO.NAME,ACCOUNT.NAME)
```



Our optimized strategy yields the following equity curve and drawdowns:

```{r,chartStrategy,echo=TRUE,fig.width=7,fig.height=5,fig.keep="last",warning=FALSE}
chart.Posn(Portfolio = PORTOLIO.NAME,symbols=symbol)
close<-Cl(get(symbol))
add_TA(SMA(close,n=30),col="blue",on=1,lwd=2)
add_TA(LRC(close,n=20),col="darkgreen",on=1,lwd=2)

accountDetails<-getAccount(Account = ACCOUNT.NAME)

```

```{r,chartStrategyplot,echo=TRUE,fig.width=7,fig.height=5,warning=FALSE}

xyplot(accountDetails$summary,type="h",col=4)

equity<-accountDetails$summary$End.Eq

plot(equity,main="LRC Equity Curve")



```

###Maximun Adverse Exursion and Maximun Favourable Excursion After Optimization

```{r,ME,echo=TRUE,fig.width=7,fig.height=5,warning=FALSE}



chart.ME(Portfolio=PORTOLIO.NAME, Symbol=symbol, type='MAE', scale='percent')
chart.ME(Portfolio=PORTOLIO.NAME, Symbol=symbol, type='MAF', scale='percent')

```

### Performance Summary

```{r,performance,echo=TRUE,results='hide',message=FALSE}

equity.curve <- getAccount(Account = ACCOUNT.NAME)$summary$End.Eq

returns.ns <- Return.calculate(equity.curve,"log")

table.AnnualizedReturns(returns.ns,geometric = FALSE)
table.AnnualizedReturns(returns.ns,geometric = TRUE)


charts.PerformanceSummary(returns.ns,wealth.index=TRUE,geometric = FALSE,
                          colorset="blue",xlab="",
                          main="LRC Performance ",minor.ticks=FALSE)


```

